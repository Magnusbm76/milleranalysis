<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RevealOnScroll Test</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        body {
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        .test-section {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #ccc;
            margin-bottom: 20px;
        }
        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div class="debug-info" id="debugInfo">
        <h3>Debug Info:</h3>
        <div id="debugContent">Initializing...</div>
    </div>

    <h1>RevealOnScroll Test</h1>
    
    <div class="test-section">
        <div class="reveal">
            <h2>Test Element 1</h2>
            <p>This should reveal when scrolled into view.</p>
        </div>
    </div>

    <div class="test-section">
        <div class="reveal">
            <h2>Test Element 2</h2>
            <p>This should also reveal when scrolled into view.</p>
        </div>
    </div>

    <div class="test-section">
        <div class="reveal">
            <h2>Test Element 3</h2>
            <p>This is the third test element.</p>
        </div>
    </div>

    <script>
        // Debug function to update debug info
        function updateDebugInfo(message) {
            const debugContent = document.getElementById('debugContent');
            debugContent.innerHTML += '<br>' + new Date().toLocaleTimeString() + ': ' + message;
            console.log(message);
        }

        // Check if IntersectionObserver is supported
        updateDebugInfo('IntersectionObserver supported: ' + ('IntersectionObserver' in window));

        // RevealOnScroll class from main.js
        class RevealOnScroll {
            constructor(options = {}) {
                // Default configuration
                this.options = {
                    threshold: options.threshold || 0.15, // 15% of element visible
                    rootMargin: options.rootMargin || '0px 0px -50px 0px', // Trigger slightly before element comes into view
                    selector: options.selector || '.reveal', // Elements to observe
                    activeClass: options.activeClass || 'active' // Class to add when revealed
                };
                
                // Store observer instance
                this.observer = null;
                
                // Initialize
                this.init();
            }
            
            init() {
                updateDebugInfo('RevealOnScroll.init() called');
                
                // Check if Intersection Observer is supported
                if (!window.IntersectionObserver) {
                    updateDebugInfo('IntersectionObserver not supported, using fallback');
                    console.warn('Intersection Observer is not supported in this browser');
                    this.fallbackInit();
                    return;
                }
                
                // Get all elements to observe
                const elementsToReveal = document.querySelectorAll(this.options.selector);
                updateDebugInfo('Found ' + elementsToReveal.length + ' elements with selector "' + this.options.selector + '"');
                
                if (elementsToReveal.length === 0) {
                    console.log(`No elements found with selector "${this.options.selector}"`);
                    return;
                }
                
                // Create Intersection Observer
                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        updateDebugInfo('Element ' + entry.target.tagName + ' isIntersecting: ' + entry.isIntersecting);
                        
                        // When element comes into view
                        if (entry.isIntersecting) {
                            entry.target.classList.add(this.options.activeClass);
                            updateDebugInfo('Added "active" class to element');
                            
                            // Optional: Stop observing after element is revealed
                            // this.observer.unobserve(entry.target);
                        }
                        // Optional: Remove class when element leaves view
                        // else {
                        //     entry.target.classList.remove(this.options.activeClass);
                        // }
                    });
                }, {
                    threshold: this.options.threshold,
                    rootMargin: this.options.rootMargin
                });
                
                // Start observing each element
                elementsToReveal.forEach((element, index) => {
                    // Set initial state (will be overridden by CSS)
                    element.style.opacity = '0';
                    element.style.transform = 'translateY(30px)';
                    element.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';
                    
                    this.observer.observe(element);
                    updateDebugInfo('Started observing element ' + (index + 1));
                });
                
                updateDebugInfo('RevealOnScroll initialized with ' + elementsToReveal.length + ' elements');
            }
            
            // Fallback for browsers that don't support Intersection Observer
            fallbackInit() {
                updateDebugInfo('Using fallback initialization');
                const elementsToReveal = document.querySelectorAll(this.options.selector);
                
                // Simple scroll event listener as fallback
                const checkScroll = () => {
                    const triggerBottom = window.innerHeight * 0.8; // 80% of viewport height
                    
                    elementsToReveal.forEach(element => {
                        const elementTop = element.getBoundingClientRect().top;
                        
                        if (elementTop < triggerBottom) {
                            element.classList.add(this.options.activeClass);
                            updateDebugInfo('Fallback: Added "active" class to element');
                        }
                    });
                };
                
                // Initial check
                checkScroll();
                
                // Throttled scroll event
                let ticking = false;
                window.addEventListener('scroll', () => {
                    if (!ticking) {
                        window.requestAnimationFrame(() => {
                            checkScroll();
                            ticking = false;
                        });
                        ticking = true;
                    }
                });
            }
            
            // Method to manually reveal an element
            revealElement(element) {
                if (element && element.classList.contains(this.options.selector.replace('.', ''))) {
                    element.classList.add(this.options.activeClass);
                }
            }
            
            // Method to manually hide an element
            hideElement(element) {
                if (element && element.classList.contains(this.options.selector.replace('.', ''))) {
                    element.classList.remove(this.options.activeClass);
                }
            }
            
            // Method to destroy the observer
            destroy() {
                if (this.observer) {
                    this.observer.disconnect();
                    this.observer = null;
                    updateDebugInfo('Observer destroyed');
                }
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            updateDebugInfo('DOM loaded');
            
            try {
                window.revealOnScroll = new RevealOnScroll({
                    threshold: 0.15,
                    rootMargin: '0px 0px -50px 0px',
                    selector: '.reveal',
                    activeClass: 'active'
                });
                updateDebugInfo('RevealOnScroll instance created successfully');
            } catch (error) {
                updateDebugInfo('Error creating RevealOnScroll: ' + error.message);
                console.error('Error creating RevealOnScroll:', error);
            }
        });
    </script>
</body>
</html>